func.func @binary_ops(%arg0: tensor<8x8xf32>, %arg1: tensor<8x8xf32>) -> tensor<f32> {
  
  //MEAN ABSOLUTE ENTROPY

    %0 = tosa.cast %arg0 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %1 = tosa.cast %arg1 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %2 = tosa.sub %0, %1 : (tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %3 = tosa.abs %2 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %4 = nova.reduce<mean> %3 dimension = [0, 1] : tensor<8x8xf32>

  //MEAN SQUARED ENTROPY

    %5 = tosa.cast %arg0 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %6 = tosa.cast %arg1 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %7 = tosa.sub %5, %6 : (tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %8 = "tosa.const"() <{values = dense<2.000000e+00> : tensor<8x8xf32>}> : () -> tensor<8x8xf32>
    %9 = tosa.pow %7, %8 : (tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %10 = nova.reduce<mean> %9 dimension = [0, 1] : tensor<8x8xf32>

  //CATEGORICAL CROSS ENTROPY

    %11 = tosa.cast %arg0 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %12 = tosa.cast %arg1 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %13 = "tosa.const"() <{values = dense<1.000000e-07> : tensor<8x8xf32>}> : () -> tensor<8x8xf32>
    %14 = "tosa.const"() <{values = dense<1.000000e+00> : tensor<8x8xf32>}> : () -> tensor<8x8xf32>
    %15 = nova.sub %14, %13 : tensor<8x8xf32>, tensor<8x8xf32>
    %16 = nova.compare<lt> %11, %13 : tensor<8x8xf32>, tensor<8x8xf32>
    %17 = tosa.select %16, %13, %11 : (tensor<8x8xi1>, tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %18 = nova.compare<gt> %17, %15 : tensor<8x8xf32>, tensor<8x8xf32>
    %19 = tosa.select %18, %15, %17 : (tensor<8x8xi1>, tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %20 = nova.log %19 : tensor<8x8xf32>
    %21 = nova.mul %20, %12 : tensor<8x8xf32>, tensor<8x8xf32>
    %22 = "tosa.const"() <{values = dense<-1.000000e+00> : tensor<f32>}> : () -> tensor<f32>
    %23 = nova.reduce<sum> %21 dimension = [1] : tensor<8x8xf32>
    %24 = nova.reduce<mean> %23 dimension = [0] : tensor<8xf32>
    %25 = nova.mul %24, %22 : tensor<f32>, tensor<f32>

  //BINARY CROSS ENTROPY

    %26 = tosa.cast %arg0 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %27 = tosa.cast %arg1 : (tensor<8x8xf32>) -> tensor<8x8xf32>
    %28 = "tosa.const"() <{values = dense<1.000000e-07> : tensor<8x8xf32>}> : () -> tensor<8x8xf32>
    %29 = "tosa.const"() <{values = dense<1.000000e+00> : tensor<8x8xf32>}> : () -> tensor<8x8xf32>
    %30 = nova.sub %29, %28 : tensor<8x8xf32>, tensor<8x8xf32>
    %31 = nova.compare<lt> %26, %28 : tensor<8x8xf32>, tensor<8x8xf32>
    %32 = tosa.select %31, %28, %26 : (tensor<8x8xi1>, tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %33 = nova.compare<gt> %32, %30 : tensor<8x8xf32>, tensor<8x8xf32>
    %34 = tosa.select %33, %30, %32 : (tensor<8x8xi1>, tensor<8x8xf32>, tensor<8x8xf32>) -> tensor<8x8xf32>
    %35 = nova.log %34 : tensor<8x8xf32>
    %36 = nova.mul %35, %27 : tensor<8x8xf32>, tensor<8x8xf32>
    %37 = nova.sub %29, %27 : tensor<8x8xf32>, tensor<8x8xf32>
    %38 = nova.sub %29, %34 : tensor<8x8xf32>, tensor<8x8xf32>
    %39 = nova.log %38 : tensor<8x8xf32>
    %40 = nova.add %37, %39 : tensor<8x8xf32>, tensor<8x8xf32>
    %41 = nova.add %36, %40 : tensor<8x8xf32>, tensor<8x8xf32>
    %42 = nova.reduce<mean> %41 dimension = [0, 1] : tensor<8x8xf32>
    %43 = "tosa.const"() <{values = dense<-1.000000e+00> : tensor<f32>}> : () -> tensor<f32>
    %44 = nova.mul %42, %43 : tensor<f32>, tensor<f32>
    return %44 : tensor<f32>
  }